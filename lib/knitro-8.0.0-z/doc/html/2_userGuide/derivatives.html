

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Derivatives &mdash; KNITRO user guide 8.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '8.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="KNITRO user guide 8.0 documentation" href="../index.html" />
    <link rel="up" title="User guide" href="../2_userGuide.html" />
    <link rel="next" title="Multistart" href="multistart.html" />
    <link rel="prev" title="Setting options" href="knitroOptions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="multistart.html" title="Multistart"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="knitroOptions.html" title="Setting options"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">KNITRO user guide 8.0 documentation</a> &raquo;</li>
          <li><a href="../2_userGuide.html" accesskey="U">User guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="derivatives">
<span id="sec-derivatives"></span><h1>Derivatives</h1>
<p id="index-0">Applications should provide partial first derivatives whenever possible, to
make KNITRO more efficient and more robust.
If first derivatives cannot be supplied, then the application should
instruct KNITRO to calculate finite-difference approximations.</p>
<p>First derivatives are represented by the gradient of the objective function
and the Jacobian matrix of the constraints. Second derivatives are represented
by Hessian matrix, a linear combination of the second derivatives of the objective
function and the constraints.</p>
<div class="section" id="first-derivatives">
<h2>First derivatives</h2>
<p id="index-1">The default version of KNITRO assumes that the user can provide exact
first derivatives to compute the objective function gradient
and constraint gradients.  It is <em>highly</em> recommended
that the user provide exact first derivatives if at all
possible, since using first derivative approximations may seriously degrade
the performance of the code and the likelihood of converging to a
solution. However, if this is not possible the following
first derivative approximation options may be used.</p>
<ul class="simple" id="index-2">
<li><em>Forward finite-differences</em>
This option uses a forward finite-difference approximation of the
objective and constraint gradients.  The cost of computing this approximation
is <em>n</em> function evaluations (where <em>n</em> is the number of
variables).  The option is invoked by choosing user option
<a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#gradopt" title="gradopt"><tt class="xref c c-type docutils literal"><span class="pre">gradopt</span></tt></a> = 2.</li>
<li><em>Centered finite-differences</em>
This option uses a centered finite-difference approximation of the
objective and constraint gradients.  The cost of computing this approximation
is <em>2n</em> function evaluations (where <em>n</em> is the number of
variables).  The option is invoked by choosing user option
<a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#gradopt" title="gradopt"><tt class="xref c c-type docutils literal"><span class="pre">gradopt</span></tt></a> = 3.
The centered finite-difference approximation is often more accurate than
the forward finite-difference approximation; however, it is more expensive
to compute if the cost of evaluating a function is high.</li>
</ul>
<p>Although these finite-differences approximations should be avoided
in general, they are useful to track errors: whenever the derivatives
are provided by the user, it is useful to check that the differentiation
(and the subsequent implementation of the derivatives) is correct.
Indeed, providing derivatives that are not coherent with the function
values is one of the most common error when solving a nonlinear program.
This check can be done automatically by comparing finite-differences
approximations with user-provided derivatives. This is explained
below (<a class="reference internal" href="#checkingderivatives"><em>Checking derivatives</em></a>).</p>
</div>
<div class="section" id="second-derivatives">
<h2>Second derivatives</h2>
<p id="index-3">The default version of KNITRO assumes that the application
can provide exact
second derivatives to compute the Hessian of the Lagrangian function.
If the application is able to do so and the cost of computing the
second derivatives is not overly expensive, it is highly
recommended to provide exact second derivatives.
However, KNITRO also offers other options
which are described in detail below.</p>
<ul id="index-4">
<li><p class="first"><em>(Dense) Quasi-Newton BFGS</em>:</p>
<p>The quasi-Newton BFGS option uses gradient
information to compute a symmetric, positive-definite
approximation to the Hessian matrix.   Typically this method requires
more iterations to converge than the exact Hessian version.  However,
since it is only computing gradients rather than Hessians, this
approach may be more efficient in some cases.  This option
stores a <em>dense</em> quasi-Newton Hessian
approximation so it is only recommended for small to medium
problems (<em>n &lt; 1000</em>).
The quasi-Newton BFGS option is chosen
by setting user option <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#hessopt" title="hessopt"><tt class="xref c c-type docutils literal"><span class="pre">hessopt</span></tt></a> = 2.</p>
</li>
<li><p class="first"><em>(Dense) Quasi-Newton SR1</em>:</p>
<p>As with the BFGS approach, the quasi-Newton SR1 approach builds an
approximate Hessian using gradient information.  However, unlike
the BFGS approximation,
the SR1 Hessian approximation is not restricted to be positive-definite.
Therefore the quasi-Newton SR1 approximation may be a better
approach, compared to the BFGS method, if there is a lot of negative
curvature in the problem since it may be able to maintain a better
approximation to the true Hessian in this
case.   The quasi-Newton SR1 approximation
maintains a <em>dense</em> Hessian approximation and so is only
recommended for small to medium problems (<em>n &lt; 1000</em>).
The quasi-Newton SR1 option is chosen
by setting user option <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#hessopt" title="hessopt"><tt class="xref c c-type docutils literal"><span class="pre">hessopt</span></tt></a> = 3.</p>
</li>
<li><p class="first"><em>Finite-difference Hessian-vector product option</em>:</p>
<p>If the problem is large and gradient evaluations are not a dominant
cost, then KNITRO can internally compute Hessian-vector products using
finite-differences.  Each Hessian-vector product in this case
requires one additional gradient evaluation.
This option is chosen by setting user option <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#hessopt" title="hessopt"><tt class="xref c c-type docutils literal"><span class="pre">hessopt</span></tt></a> = 4.
The option is only recommended if the exact gradients are provided.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This option may not be used when <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#algorithm" title="algorithm"><tt class="xref c c-type docutils literal"><span class="pre">algorithm</span></tt></a> = 1 since the IP/direct
algorithm needs the full expression of the Hessian matrix
(Hessian-vector products are not sufficient).</p>
</div>
<ul>
<li><p class="first"><em>Exact Hessian-vector products</em>:</p>
<p>In some cases the application may prefer to provide exact Hessian-vector
products, but not the full Hessian (for instance, if the problem
has a large, dense Hessian).  The application must provide a routine
which, given a vector <em>v</em> (stored in <em>hessVector</em>), computes the
Hessian-vector product, <em>H*v</em>, and returns the result (again in <em>hessVector</em>).
This option is chosen by setting user option <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#hessopt" title="hessopt"><tt class="xref c c-type docutils literal"><span class="pre">hessopt</span></tt></a> = 5.</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This option may not be used when <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#algorithm" title="algorithm"><tt class="xref c c-type docutils literal"><span class="pre">algorithm</span></tt></a> = 1 since,
as mentioned above, the IP/direct
algorithm needs the full expression of the Hessian matrix
(Hessian-vector products are not sufficient).</p>
</div>
<ul>
<li><p class="first"><em>Limited-memory Quasi-Newton BFGS</em>:</p>
<p>The limited-memory quasi-Newton BFGS option is similar to the
dense quasi-Newton BFGS option described above.  However, it is better
suited for large-scale problems since, instead of storing a dense
Hessian approximation, it stores only a limited number of gradient
vectors used to approximate the Hessian.  The number of gradient
vectors used to approximate the Hessian is controlled by user option
<a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#lmsize" title="lmsize"><tt class="xref c c-type docutils literal"><span class="pre">lmsize</span></tt></a>.</p>
<p>A larger value of <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#lmsize" title="lmsize"><tt class="xref c c-type docutils literal"><span class="pre">lmsize</span></tt></a> may result in a more
accurate, but also more expensive, Hessian approximation.  A smaller
value may give a less accurate, but faster, Hessian approximation. When
using the limited memory BFGS approach it is recommended to experiment
with different values of this parameter (e.g. between 5 and 15).</p>
<p>In general, the limited-memory BFGS option requires
more iterations to converge than the dense quasi-Newton BFGS approach,
but will be much more efficient on large-scale problems.
The limited-memory quasi-Newton option is chosen by
setting user option <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#hessopt" title="hessopt"><tt class="xref c c-type docutils literal"><span class="pre">hessopt</span></tt></a> = 6.</p>
</li>
</ul>
<p>As with exact first derivatives, exact second derivatives often provide a
substantial benefit to KNITRO and it is advised to provide them whenever
possible.</p>
</div>
<div class="section" id="jacobian-and-hessian-derivative-matrices">
<h2>Jacobian and Hessian derivative matrices</h2>
<p>The Jacobian matrix of the constraints is defined as</p>
<div class="math">
<p><img src="../_images/math/fbf63580036b7cfe80a4f2abf35886c9e8e81f41.png" alt="J(x) = \begin{bmatrix}
\nabla c_0(x) &amp;
\dots &amp;
\nabla c_m(x)
\end{bmatrix}"/></p>
</div><p>and the Hessian matrix of the Lagrangian is defined as</p>
<div class="math">
<p><img src="../_images/math/85c0097fccec13abc26a79e3f674cad6af5f5a36.png" alt="H(x,\lambda) = \sigma \nabla^2 f(x) + \sum_{i=0}^{m-1} \lambda_i \nabla^2 c_i(x)"/></p>
</div><p>where <img class="math" src="../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/> is the vector of Lagrange multipliers (dual variables),
and <img class="math" src="../_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> is a scalar (either 0 or 1) for the objective component of
the Hessian that was introduced in KNITRO 8.0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For backwards compatibility
with older versions of KNITRO, the user can always assume that
<img class="math" src="../_images/math/721917ef47034af7104b5f9a020702022c8afc38.png" alt="\sigma=1"/> if the user option <tt class="xref c c-type docutils literal"><span class="pre">hessian_no_f=0</span></tt> (which is the
default setting).  However, if <tt class="xref c c-type docutils literal"><span class="pre">hessian_no_f=1</span></tt>, then KNITRO will
provide a status flag to the user when it needs a Hessian evaluation
indicating whether the Hessian should be evaluated with
<img class="math" src="../_images/math/5404e4a99864a06a47b97e4f819ce41292447fbe.png" alt="\sigma=0"/> or <img class="math" src="../_images/math/721917ef47034af7104b5f9a020702022c8afc38.png" alt="\sigma=1"/>.  The user must then evaluate the Hessian with
the proper value of <img class="math" src="../_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> based on this status flag.
Setting <tt class="xref c c-type docutils literal"><span class="pre">hessian_no_f=1</span></tt> and computing the Hessian with the requested
value of <img class="math" src="../_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/> may improve KNITRO efficiency in some cases.
Examples of how to do this can be found in the <tt class="file docutils literal"><span class="pre">examples/C</span></tt> directory.</p>
</div>
<p class="rubric">Example</p>
<p>Assume we want to use KNITRO to solve the following problem:</p>
<div class="math">
<p><img src="../_images/math/f25a6974ff9b314aa61d226a95becfb075e67cfa.png" alt="\min \; x_0 + x_1 x_2^3

\mbox{subject to:}

\cos(x_0) = 0.5 \\
3  \le x_0^2+x_1^2 \le 8 \\
x_0 + x_1 + x_2 \le &amp; 10 \\
x_0, x_1, x_2 \ge 1."/></p>
</div><p>Rewriting in the KNITRO standard notation, we have</p>
<div class="math">
<p><img src="../_images/math/3ca16f48ee546fd63d923b5523c27fc7ebeae161.png" alt="f(x)   &amp; = x_0 + x_1 x_2^3  \\
c_0(x) &amp; = \cos(x_0) \\
c_1(x) &amp; = x_0^2+x_1^2 \\
c_2(x) &amp; = x_0 + x_1 + x_2."/></p>
</div><p class="rubric">Computing the Sparse Jacobian Matrix</p>
<p>The gradients (first derivatives) of the objective and constraint
functions are given by</p>
<div class="math">
<p><img src="../_images/math/423e687d95f648e6b163e4ee85a7d0851044c93b.png" alt="\nabla f(x) = \begin{bmatrix} 1 \\ x_2^3 \\ 3 x_1 x_2^2 \end{bmatrix},
\nabla c_0(x) = \begin{bmatrix} -\sin(x_0) \\ 0 \\ 0 \end{bmatrix},
\nabla c_1(x) = \begin{bmatrix} 2 x_0 \\ 2 x_1 \\ 0 \end{bmatrix},
\nabla c_2(x) = \begin{bmatrix} 1 \\ 1 \\ 1 \end{bmatrix}."/></p>
</div><p>The constraint Jacobian matrix <img class="math" src="../_images/math/5cc4198c5880dd4ab2cd740959d0c7659c8d0a55.png" alt="J(x)"/> is the matrix whose rows store the
(transposed) constraint gradients, i.e.,</p>
<div class="math">
<p><img src="../_images/math/01bae8162550c33e119e5f0bb3790ab7aea24c8c.png" alt="J(x) = \begin{bmatrix} \nabla c_0(x)^T \\ \nabla c_1(x)^T \\ \nabla c_2(x)^T \end{bmatrix} =
\begin{bmatrix}
-\sin(x_0)  &amp; 0      &amp; 0 \\
2 x_0       &amp; 2 x_1  &amp; 0 \\
1           &amp; 1      &amp; 1
\end{bmatrix} ."/></p>
</div><p>The values of <img class="math" src="../_images/math/5cc4198c5880dd4ab2cd740959d0c7659c8d0a55.png" alt="J(x)"/> depend on the value of <img class="math" src="../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"/> and change during
the
solution process.  The indices specifying the nonzero elements of this matrix
remain constant and are set in <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_init_problem" title="KTR_init_problem"><tt class="xref c c-func docutils literal"><span class="pre">KTR_init_problem()</span></tt></a> by the values of
<em>jacIndexCons</em> and <em>jacIndexVars</em>.</p>
<p class="rubric">Computing the Sparse Hessian Matrix</p>
<p>For the example above, the Hessians (second derivatives) of the objective
function is given by</p>
<div class="math">
<p><img src="../_images/math/e0c60a6957edfd9b84aeecd08a286471f8e652af.png" alt="\nabla^2 f(x) =
\begin{bmatrix}
     0           &amp; 0       &amp; 0 \\
     0           &amp; 0       &amp; 3 x_2^2 \\
         0           &amp; 3 x_2^2 &amp; 6 x_1 x_2
\end{bmatrix},"/></p>
</div><p>and the Hessians of constraints are given by</p>
<div class="math">
<p><img src="../_images/math/cb6d00fe0fcf1326ff4ab5ecd063e0b981b129d0.png" alt="\nabla^2 c_0(x) =
\begin{bmatrix}
     -\cos(x_0)  &amp; 0       &amp; 0 \\
     0           &amp; 0       &amp; 0 \\
         0           &amp; 0       &amp; 0
\end{bmatrix},
    \nabla^2 c_1(x) =
\begin{bmatrix}
     2           &amp; 0       &amp; 0 \\
     0           &amp; 2       &amp; 0 \\
         0           &amp; 0       &amp; 0
\end{bmatrix},
    \nabla^2 c_2(x) =
\begin{bmatrix}
     0           &amp; 0       &amp; 0 \\
     0           &amp; 0       &amp; 0 \\
         0           &amp; 0       &amp; 0
\end{bmatrix}."/></p>
</div><p>Scaling the objective matrix by <img class="math" src="../_images/math/fa35d9fc104207e09a712110ac81612c5b279a6c.png" alt="\sigma"/>, and the constraint matrices
by their corresponding Lagrange
multipliers and summing, we get</p>
<div class="math">
<p><img src="../_images/math/d8352eee82d9d79f481e171f7ff4008720d6aa86.png" alt="H(x,\lambda) =
\begin{bmatrix}
  -\lambda_0 \cos(x_0) + 2 \lambda_1  &amp; 0 &amp; 0 \\
  0 &amp; 2 \lambda_1  &amp; \sigma 3 x_2^2 \\
      0 &amp; \sigma 3 x_2^2      &amp; \sigma 6 x_1 x_2
\end{bmatrix} ."/></p>
</div><p>The values of <img class="math" src="../_images/math/e2eb5645ceb3678b25267f3fb533a67c59015654.png" alt="H(x,\lambda)"/> depend on the value of <img class="math" src="../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"/> and <img class="math" src="../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda"/>
and change during the
solution process.  The indices specifying the nonzero elements of this matrix
remain constant and are set in <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_init_problem" title="KTR_init_problem"><tt class="xref c c-func docutils literal"><span class="pre">KTR_init_problem()</span></tt></a> by the values of
<em>hessIndexRows</em> and <em>hessIndexCols</em>.</p>
</div>
<div class="section" id="inputing-derivatives">
<h2>Inputing derivatives</h2>
<p id="index-5">MATLAB users can provide the Jacobian and Hessian matrices in standard
MATLAB format, either dense or sparse.
Users of the callable library must provide derivatives to KNITRO in sparse
format. In the above example, the number of nonzero elements <em>nnzJ</em>
in <em>J(x)</em> is 6, and these arrays would be specified as
follows (here in column-wise order, but the order is arbitrary)
using the callable library.</p>
<div class="highlight-none"><div class="highlight"><pre>jac[0] = -sin(x[0]);  jacIndexCons[0] = 0; jacIndexVars[0] = 0;
jac[1] = 2*x[0];      jacIndexCons[1] = 1; jacIndexVars[1] = 0;
jac[2] = 1;           jacIndexCons[2] = 2; jacIndexVars[2] = 0;
jac[3] = 2*x[1];      jacIndexCons[3] = 1; jacIndexVars[3] = 1;
jac[4] = 1;           jacIndexCons[4] = 2; jacIndexVars[4] = 1;
jac[5] = 1;           jacIndexCons[5] = 2; jacIndexVars[5] = 2;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Even if the application does not
evaluate derivatives, it must still provide a sparsity pattern for the constraint
Jacobian matrix that specifies which partial derivatives are nonzero.
KNITRO uses the sparsity pattern to speed up linear algebra computations.
If the sparsity pattern is unknown, then the application should specify a
fully dense pattern (i.e., assume all partial derivatives are nonzero).</p>
</div>
<p>Since the Hessian matrix will always be a symmetric matrix, KNITRO only
stores the nonzero elements corresponding to the upper triangular part
(including the diagonal). In the example here, the number of nonzero
elements in the upper triangular part of the Hessian matrix <em>nnzH</em> is
4.  The KNITRO array <em>hess</em> stores the values of these
elements, while the arrays <em>hessIndexRows</em> and <em>hessIndexCols</em>
store the row and
column indices respectively.  The order in which these nonzero
elements is stored is not important.  If we store them column-wise,
the arrays <em>hess</em>, <em>hessIndexRows</em> and <em>hessIndexCols</em> are as
follows:</p>
<div class="highlight-none"><div class="highlight"><pre>hess[0] = -lambda[0]*cos(x[0]) + 2*lambda[1];
hessIndexRows[0] = 0;
hessIndexCols[0] = 0;

hess[1] = 2*lambda[1];
hessIndexRows[1] = 1;
hessIndexCols[1] = 1;

hess[2] = sigma*3*x[2]*x[2];
hessIndexRows[2] = 1;
hessIndexCols[2] = 2;

hess[3] = sigma*6*x[1]*x[2];
hessIndexRows[3] = 2;
hessIndexCols[3] = 2;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In KNITRO, the array <em>objGrad</em> stores <em>all</em> of the elements of
<img class="math" src="../_images/math/e4ba48c6cde64210e05893649bb4cab165ec2a43.png" alt="\nabla f(x)"/>, while the arrays <em>jac</em>, <em>jacIndexCons</em>, and
<em>jacIndexVars</em> store information concerning <em>only the nonzero</em>
elements of <em>J(x)</em>.  The array <em>jac</em> stores the nonzero values in
<em>J(x)</em> evaluated at the current solution estimate <em>x</em>,
<em>jacIndexCons</em> stores the constraint function (or row) indices
corresponding to these values, and <em>jacIndexVars</em> stores the variable
(or column) indices.  There is no
restriction on the order in which these elements are stored; however,
it is common to store the nonzero elements of <em>J(x)</em> in column-wise
fashion.</p>
</div>
</div>
<div class="section" id="matlab-example">
<span id="matlabexamplefirstder"></span><h2>MATLAB example</h2>
<p>Let us modify our example from <a class="reference internal" href="gettingStarted/startMatlab.html#startmatlab"><em>Getting started with MATLAB</em></a> so that the first
derivatives are provided as well.  In MATLAB, you only need to provide the
derivatives for the nonlinear functions, whereas in the callable library API
you need to provide the derivatives for both linear and nonlinear constraints
in <img class="math" src="../_images/math/5cc4198c5880dd4ab2cd740959d0c7659c8d0a55.png" alt="J(x)"/>.  In the example below, only the inequality constraint is
nonlinear, so we only provide the derivative for this constraint.</p>
<div class="highlight-none"><div class="highlight"><pre>function firstDer()

        function [f, g] = obj(x)
                f = 1000 - x(1)^2 - 2*x(2)^2 - x(3)^2 - x(1)*x(2) - x(1)*x(3);
                if nargout == 2
                   g = [-2*x(1) - x(2) - x(3); - 4*x(2) - x(1); -2*x(3) - x(1)];
                end
        end

        % nlcon should return [c, ceq, GC, GCeq]
        % with c(x) &lt;= 0 and ceq(x) = 0
        function [c, ceq, GC, GCeq] = nlcon(x)
                c = -(x(1)^2 + x(2)^2 + x(3)^2 - 25);
                ceq = [];
                if nargout==4
                        GC = -([2*x(1); 2*x(2); 2*x(3)]);
                        GCeq = [];
                end
        end

        x0  = [2; 2; 2];
        A = []; b = []; % no linear inequality constraints (&quot;A*x &lt;= b&quot;)
        Aeq = [8 14 7]; beq = [56]; % linear equality constraints (&quot;Aeq*x = beq&quot;)
        lb = zeros(3,1); ub = []; % lower and upper bounds

        options = optimset(&#39;GradObj&#39;, &#39;on&#39;, &#39;GradConstr&#39;, &#39;on&#39;);
        ktrlink(@obj, x0, A, b, Aeq, beq, lb, ub, @nlcon, options);

end
</pre></div>
</div>
<p>The only difference with the derivative-free case is that the code
that computes the objective function and the constraints also returns
the first derivatives along with function values. The output is as follows.</p>
<div class="highlight-none"><div class="highlight"><pre>======================================
       Commercial Ziena License
             KNITRO 8.0.0
          Ziena Optimization
======================================

KNITRO presolve eliminated 0 variables and 0 constraints.

algorithm:            1
hessopt:              2
honorbnds:            1
maxit:                10000
outlev:               1
KNITRO changing bar_switchrule from AUTO to 2.
KNITRO changing bar_murule from AUTO to 4.
KNITRO changing bar_initpt from AUTO to 2.
KNITRO changing bar_penaltyrule from AUTO to 2.
KNITRO changing bar_penaltycons from AUTO to 1.
KNITRO changing linsolver from AUTO to 2.

Problem Characteristics
-----------------------
Objective goal:  Minimize
Number of variables:                     3
    bounded below:                       3
    bounded above:                       0
    bounded below and above:             0
    fixed:                               0
    free:                                0
Number of constraints:                   2
    linear equalities:                   1
    nonlinear equalities:                0
    linear inequalities:                 0
    nonlinear inequalities:              1
    range:                               0
Number of nonzeros in Jacobian:          6
Number of nonzeros in Hessian:           6

EXIT: Locally optimal solution found.

Final Statistics
----------------
Final objective value               =   9.36000000020000e+02
Final feasibility error (abs / rel) =   0.00e+00 / 0.00e+00
Final optimality error  (abs / rel) =   2.38e-09 / 1.49e-10
# of iterations                     =          9
# of CG iterations                  =          0
# of function evaluations           =         10
# of gradient evaluations           =         10
Total program time (secs)           =       0.04665 (     0.064 CPU time)
Time spent in evaluations (secs)    =       0.02377

===============================================================================
</pre></div>
</div>
<p>The number of function evaluation was reduced to 10, simply by providing exact first derivatives.
This small example shows the practical importance of being able to provide
exact derivatives; since (unlike modeling environments like AMPL) MATLAB does not
provide automatic differentiation, the user must compute these derivatives analytically
and then code them manually as in the above example.</p>
</div>
<div class="section" id="c-c-example">
<h2>C/C++ example</h2>
<p>Let us now modify our C example from <a class="reference internal" href="gettingStarted/startCallableLibrary.html#startcallablelib"><em>Getting started with the callable library</em></a> similarly,
so as to provide first derivatives.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &quot;knitro.h&quot;</span>


<span class="cm">/* callback function that evaluates the objective</span>
<span class="cm">   and constraints */</span>
<span class="kt">int</span>  <span class="nf">callback</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">evalRequestCode</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">nnzJ</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">nnzH</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">lambda</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">obj</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">c</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">objGrad</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">jac</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">hessian</span><span class="p">,</span>
              <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">hessVector</span><span class="p">,</span>
              <span class="kt">void</span>   <span class="o">*</span>        <span class="n">userParams</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">evalRequestCode</span> <span class="o">==</span> <span class="n">KTR_RC_EVALFC</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* objective function */</span>
                <span class="o">*</span><span class="n">obj</span>    <span class="o">=</span> <span class="mi">1000</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

                <span class="cm">/* constraints */</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">14</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">56</span><span class="p">;</span>
                <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>    <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span><span class="mi">25</span><span class="p">;</span>

                <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">evalRequestCode</span> <span class="o">==</span> <span class="n">KTR_RC_EVALGA</span><span class="p">)</span> <span class="p">{</span>

                <span class="cm">/* gradient of objective */</span>
                <span class="n">objGrad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">objGrad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">objGrad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

                <span class="cm">/* Jacobian matrix of constraints */</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
                <span class="n">jac</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

                <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Wrong evalRequestCode in callback function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* main */</span>
<span class="kt">int</span>  <span class="nf">main</span> <span class="p">(</span><span class="kt">int</span>  <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
        <span class="kt">int</span>  <span class="n">nStatus</span><span class="p">;</span>

        <span class="cm">/* variables that are passed to KNITRO */</span>
        <span class="n">KTR_context</span>     <span class="o">*</span><span class="n">kc</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">nnzJ</span><span class="p">,</span> <span class="n">nnzH</span><span class="p">,</span> <span class="n">objGoal</span><span class="p">,</span> <span class="n">objType</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">cType</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">jacIndexVars</span><span class="p">,</span> <span class="o">*</span><span class="n">jacIndexCons</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">lambda</span><span class="p">;</span>
        <span class="kt">double</span> <span class="o">*</span><span class="n">xLoBnds</span><span class="p">,</span> <span class="o">*</span><span class="n">xUpBnds</span><span class="p">,</span> <span class="o">*</span><span class="n">xInitial</span><span class="p">,</span> <span class="o">*</span><span class="n">cLoBnds</span><span class="p">,</span> <span class="o">*</span><span class="n">cUpBnds</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span> <span class="c1">// convenience variables</span>

        <span class="cm">/*problem size and mem allocation */</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">nnzJ</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">m</span><span class="p">;</span>
        <span class="n">nnzH</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">x</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span>     <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">lambda</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">((</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">xLoBnds</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">xUpBnds</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">xInitial</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">cType</span>        <span class="o">=</span> <span class="p">(</span><span class="kt">int</span>    <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">cLoBnds</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">cUpBnds</span>      <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">));</span>
        <span class="n">jacIndexVars</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span>    <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">nnzJ</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">jacIndexCons</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span>    <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">nnzJ</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

        <span class="cm">/* objective type */</span>
        <span class="n">objType</span> <span class="o">=</span> <span class="n">KTR_OBJTYPE_GENERAL</span><span class="p">;</span>
        <span class="n">objGoal</span> <span class="o">=</span> <span class="n">KTR_OBJGOAL_MINIMIZE</span><span class="p">;</span>

        <span class="cm">/* bounds and constraints type */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">xLoBnds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                <span class="n">xUpBnds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_INFBOUND</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cType</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_CONTYPE_GENERAL</span><span class="p">;</span>
                <span class="n">cLoBnds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                <span class="n">cUpBnds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="n">KTR_INFBOUND</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/* initial point */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">xInitial</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>

        <span class="cm">/* sparsity pattern (here, of a full matrix) */</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">jacIndexCons</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                        <span class="n">jacIndexVars</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>

        <span class="cm">/* create a KNITRO instance */</span>
        <span class="n">kc</span> <span class="o">=</span> <span class="n">KTR_new</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">kc</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span> <span class="c1">// probably a license issue</span>

        <span class="cm">/* set options: exact/user-supplied gradient option */</span>
        <span class="c1">//if (KTR_set_int_param_by_name (kc, &quot;gradopt&quot;, KTR_GRADOPT_FORWARD) != 0)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KTR_set_int_param_by_name</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="s">&quot;gradopt&quot;</span><span class="p">,</span> <span class="n">KTR_GRADOPT_EXACT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KTR_set_int_param_by_name</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="s">&quot;hessopt&quot;</span><span class="p">,</span> <span class="n">KTR_HESSOPT_BFGS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KTR_set_int_param_by_name</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="s">&quot;outlev&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>

        <span class="cm">/* register the callback function */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KTR_set_func_callback</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">KTR_set_grad_callback</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">callback</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">(</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>

        <span class="cm">/* pass the problem definition to KNITRO */</span>
        <span class="n">nStatus</span> <span class="o">=</span> <span class="n">KTR_init_problem</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">objGoal</span><span class="p">,</span> <span class="n">objType</span><span class="p">,</span>
                <span class="n">xLoBnds</span><span class="p">,</span> <span class="n">xUpBnds</span><span class="p">,</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">cType</span><span class="p">,</span> <span class="n">cLoBnds</span><span class="p">,</span> <span class="n">cUpBnds</span><span class="p">,</span>
                <span class="n">nnzJ</span><span class="p">,</span> <span class="n">jacIndexVars</span><span class="p">,</span> <span class="n">jacIndexCons</span><span class="p">,</span>
                <span class="n">nnzH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">xInitial</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="cm">/* free memory (KNITRO maintains its own copy) */</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">xLoBnds</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">xUpBnds</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">xInitial</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">cType</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">cLoBnds</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">cUpBnds</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">jacIndexVars</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">jacIndexCons</span><span class="p">);</span>

        <span class="cm">/* solver call */</span>
        <span class="n">nStatus</span> <span class="o">=</span> <span class="n">KTR_solve</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lambda</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span>
                <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">KNITRO failed to solve the problem, final status = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                                <span class="n">nStatus</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">KNITRO successful, objective is = %e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>

        <span class="cm">/* delete the KNITRO instance and primal/dual solution */</span>
        <span class="n">KTR_free</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">kc</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">free</span> <span class="p">(</span><span class="n">lambda</span><span class="p">);</span>

        <span class="n">getchar</span><span class="p">();</span>
        <span class="k">return</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The call back function was simply updated to provide the derivatives,
and then registered with:</p>
<div class="highlight-python"><pre>KTR_set_grad_callback (kc, &amp;callback)</pre>
</div>
<p>Last, the <a class="reference internal" href="../3_referenceManual/callableLibrary/userOptions.html#gradopt" title="gradopt"><tt class="xref c c-type docutils literal"><span class="pre">gradopt</span></tt></a> option was set to exact/user-supplied) instead of
forward finite-differences using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">KTR_set_int_param_by_name</span> <span class="p">(</span><span class="n">kc</span><span class="p">,</span> <span class="s">&quot;gradopt&quot;</span><span class="p">,</span> <span class="n">KTR_GRADOPT_EXACT</span><span class="p">)</span>
</pre></div>
</div>
<p>Running this code produces the following output.</p>
<div class="highlight-none"><div class="highlight"><pre>======================================
       Commercial Ziena License
             KNITRO 8.0.0
          Ziena Optimization
======================================

KNITRO presolve eliminated 0 variables and 0 constraints.

hessopt:              2
outlev:               1
KNITRO changing bar_switchrule from AUTO to 2.
KNITRO changing algorithm from AUTO to 1.
KNITRO changing bar_murule from AUTO to 4.
KNITRO changing bar_initpt from AUTO to 2.
KNITRO changing bar_penaltyrule from AUTO to 2.
KNITRO changing bar_penaltycons from AUTO to 1.
KNITRO changing linsolver from AUTO to 2.

Problem Characteristics
-----------------------
Objective goal:  Minimize
Number of variables:                     3
    bounded below:                       3
    bounded above:                       0
    bounded below and above:             0
    fixed:                               0
    free:                                0
Number of constraints:                   2
    linear equalities:                   0
    nonlinear equalities:                1
    linear inequalities:                 0
    nonlinear inequalities:              1
    range:                               0
Number of nonzeros in Jacobian:          6
Number of nonzeros in Hessian:           6

EXIT: Locally optimal solution found.

Final Statistics
----------------
Final objective value               =   9.36000000017290e+02
Final feasibility error (abs / rel) =   0.00e+00 / 0.00e+00
Final optimality error  (abs / rel) =   2.61e-07 / 1.63e-08
# of iterations                     =          8
# of CG iterations                  =          0
# of function evaluations           =          9
# of gradient evaluations           =          9
Total program time (secs)           =       0.00194 (     0.002 CPU time)
Time spent in evaluations (secs)    =       0.00000

===============================================================================


KNITRO successful, objective is = 9.360000e+02
</pre></div>
</div>
<p>Again, the number of function calls is reduced with respect to the
derivative-free case.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Automatic differentiation packages like ADOL-C and ADIFOR
can help in generating code with derivatives. These codes
are an alternative to differentiating the functions manually.
Another option is to use symbolic differentiation software
to compute an analytical formula for the derivatives.</p>
</div>
</div>
<div class="section" id="checking-derivatives">
<span id="checkingderivatives"></span><h2>Checking derivatives</h2>
<p id="index-6">One drawback of user-suppled derivatives is the risk of error in
computing or implementing the derivatives, that would result in
providing KNITRO with (wrong and) incoherent information: the
computed function values would not match the computed derivatives.
Approximate derivatives computed by finite differences are useful to
check whether user-supplied derivatives match user-supplied function
evaluations.</p>
<p>Users of modeling languages such as AMPL need not be worried about this,
since derivatives are computed automatically by the modeling software.
However, for users of MATLAB and the callable library it is a good practice
to check one&#8217;s exact derivatives against finite differences approximations.
Note that small differences between exact and finite-difference
approximations are to be expected. Also, it is best to check the
gradient at different points, and to avoid points where partial
derivatives happen to equal zero.</p>
<p>For MATLAB users, <em>fmincon</em> offers a <em>DerivativeCheck</em>
option that provides this functionality.
With the callable library, modify your application and replace
the call to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">KTR_solve</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>or <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_solve" title="KTR_mip_solve"><tt class="xref c c-func docutils literal"><span class="pre">KTR_mip_solve()</span></tt></a>, with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">KTR_check_first_ders</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>A typical call looks like this:</p>
<div class="highlight-python"><pre>/* /!\ x should be initialized before the call */
KTR_check_first_ders(kc, x, 2, 1e-6, 1e-6, 0, 0.0, NULL, NULL, NULL, NULL);</pre>
</div>
<p>where <em>kc</em> is the KNITRO context pointer and <em>x</em> is the solution vector.
Refer for instance to <tt class="file docutils literal"><span class="pre">knitro.h</span></tt> for the other options.
KNITRO will then call the user routine for exact gradients, compute
finite-difference approximations, and print any differences
that exceed a given threshold. KNITRO also checks that the sparse constraint
Jacobian has all nonzero elements defined.  The check can be made with
forward or centered differences.</p>
<p>For instance, let us modify the above example
(the C toy problem with first derivatives)
by replacing the call to <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_solve" title="KTR_solve"><tt class="xref c c-func docutils literal"><span class="pre">KTR_solve()</span></tt></a> as follows:</p>
<div class="highlight-python"><pre>/* solver call */
//nStatus = KTR_solve (kc, x, lambda, 0, &amp;obj,
//                     NULL, NULL, NULL, NULL, NULL, NULL);
    x[0] = 1.0;
    x[1] = 1.0;
    x[2] = 1.0;
    nStatus = KTR_check_first_ders (kc, x, 2, 1e-6, 1e-6, 0, 0.0, NULL, NULL, NULL, NULL);
    exit( 0 );</pre>
</div>
<p>Running the code produces the following &#8220;empty&#8221; output:</p>
<div class="highlight-python"><pre>-----------------------------------------------------
KNITRO 8.0.0
Check 1st Derivatives with Central Finite Differences
Print absolute differences &gt;  1.0000e-006
and relative differences &gt;  1.0000e-006
-----------------------------------------------------</pre>
</div>
<p>that shows that our exact derivatives are correct.
Now let us modify the objective gradient computation
as follows:</p>
<div class="highlight-python"><pre>/* gradient of objective */
//objGrad[0] = -2*x[0] - x[1] - x[2];
objGrad[0] = -2*x[0] - x[1]; // BUG HERE !!!</pre>
</div>
<p>Running the code again, we obtain:</p>
<div class="highlight-python"><pre>-----------------------------------------------------
KNITRO 8.0.0
Check 1st Derivatives with Central Finite Differences
Print absolute differences &gt;  1.0000e-006
and relative differences &gt;  1.0000e-006
-----------------------------------------------------

WARNING: objGrad[0], absolute and relative discrepancy:
 --&gt; FD = -4.00000002e+000, analytic = -3.00000000e+000, |diff| = 1.0000e+000</pre>
</div>
<p>KNITRO is warning us that the finite difference approximation of
the first coordinate of the gradient is about -4, whereas its
(supposedly) exact user-supplied value is about -3: there is a
bug in our implementation of the gradient of the objective.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Derivatives</a><ul>
<li><a class="reference internal" href="#first-derivatives">First derivatives</a></li>
<li><a class="reference internal" href="#second-derivatives">Second derivatives</a></li>
<li><a class="reference internal" href="#jacobian-and-hessian-derivative-matrices">Jacobian and Hessian derivative matrices</a></li>
<li><a class="reference internal" href="#inputing-derivatives">Inputing derivatives</a></li>
<li><a class="reference internal" href="#matlab-example">MATLAB example</a></li>
<li><a class="reference internal" href="#c-c-example">C/C++ example</a></li>
<li><a class="reference internal" href="#checking-derivatives">Checking derivatives</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="knitroOptions.html"
                        title="previous chapter">Setting options</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="multistart.html"
                        title="next chapter">Multistart</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="multistart.html" title="Multistart"
             >next</a> |</li>
        <li class="right" >
          <a href="knitroOptions.html" title="Setting options"
             >previous</a> |</li>
        <li><a href="../index.html">KNITRO user guide 8.0 documentation</a> &raquo;</li>
          <li><a href="../2_userGuide.html" >User guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Ziena Optimization LLC.
    </div>
  </body>
</html>